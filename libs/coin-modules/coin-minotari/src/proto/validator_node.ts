// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v3.19.6
// source: validator_node.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { GetIdentityRequest, GetIdentityResponse } from "./network";
import { TransactionOutput } from "./transaction";

export const protobufPackage = "tari.rpc";

/**
 * Copyright 2021. The Tari Project
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/** empty */
export interface GetConstitutionRequestsRequest {
}

/** empty */
export interface GetMetadataRequest {
}

export interface PublishContractAcceptanceRequest {
  contractId: Uint8Array;
}

export interface PublishContractAcceptanceResponse {
  status: string;
  txId: Long;
}

export interface PublishContractUpdateProposalAcceptanceRequest {
  contractId: Uint8Array;
  proposalId: Long;
}

export interface PublishContractUpdateProposalAcceptanceResponse {
  status: string;
  txId: Long;
}

export interface GetMetadataResponse {
  sidechains: SidechainMetadata[];
}

export interface SidechainMetadata {
  assetPublicKey: Uint8Array;
  committedHeight: Long;
  committedHash: Uint8Array;
}

export interface GetTokenDataRequest {
  assetPubKey: Uint8Array;
  uniqueId: Uint8Array;
}

export interface GetTokenDataResponse {
}

export interface InvokeReadMethodRequest {
  contractId: Uint8Array;
  templateId: number;
  method: string;
  args: Uint8Array;
  sender: Uint8Array;
}

export interface InvokeReadMethodResponse {
  result: Uint8Array;
  authority: Authority | undefined;
}

export interface Authority {
  nodePublicKey: Uint8Array;
  signature: Uint8Array;
  proxiedBy: Uint8Array;
}

export interface InvokeMethodRequest {
  contractId: Uint8Array;
  templateId: number;
  method: string;
  args: Uint8Array;
  sender: Uint8Array;
}

export interface InvokeMethodResponse {
  status: string;
  result: Uint8Array;
}

function createBaseGetConstitutionRequestsRequest(): GetConstitutionRequestsRequest {
  return {};
}

export const GetConstitutionRequestsRequest = {
  encode(_: GetConstitutionRequestsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConstitutionRequestsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConstitutionRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetConstitutionRequestsRequest {
    return {};
  },

  toJSON(_: GetConstitutionRequestsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConstitutionRequestsRequest>, I>>(base?: I): GetConstitutionRequestsRequest {
    return GetConstitutionRequestsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConstitutionRequestsRequest>, I>>(_: I): GetConstitutionRequestsRequest {
    const message = createBaseGetConstitutionRequestsRequest();
    return message;
  },
};

function createBaseGetMetadataRequest(): GetMetadataRequest {
  return {};
}

export const GetMetadataRequest = {
  encode(_: GetMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMetadataRequest {
    return {};
  },

  toJSON(_: GetMetadataRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetadataRequest>, I>>(base?: I): GetMetadataRequest {
    return GetMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetadataRequest>, I>>(_: I): GetMetadataRequest {
    const message = createBaseGetMetadataRequest();
    return message;
  },
};

function createBasePublishContractAcceptanceRequest(): PublishContractAcceptanceRequest {
  return { contractId: new Uint8Array(0) };
}

export const PublishContractAcceptanceRequest = {
  encode(message: PublishContractAcceptanceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractId.length !== 0) {
      writer.uint32(10).bytes(message.contractId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishContractAcceptanceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishContractAcceptanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishContractAcceptanceRequest {
    return { contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0) };
  },

  toJSON(message: PublishContractAcceptanceRequest): unknown {
    const obj: any = {};
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishContractAcceptanceRequest>, I>>(
    base?: I,
  ): PublishContractAcceptanceRequest {
    return PublishContractAcceptanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishContractAcceptanceRequest>, I>>(
    object: I,
  ): PublishContractAcceptanceRequest {
    const message = createBasePublishContractAcceptanceRequest();
    message.contractId = object.contractId ?? new Uint8Array(0);
    return message;
  },
};

function createBasePublishContractAcceptanceResponse(): PublishContractAcceptanceResponse {
  return { status: "", txId: Long.UZERO };
}

export const PublishContractAcceptanceResponse = {
  encode(message: PublishContractAcceptanceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.txId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishContractAcceptanceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishContractAcceptanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.txId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishContractAcceptanceResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO,
    };
  },

  toJSON(message: PublishContractAcceptanceResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishContractAcceptanceResponse>, I>>(
    base?: I,
  ): PublishContractAcceptanceResponse {
    return PublishContractAcceptanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishContractAcceptanceResponse>, I>>(
    object: I,
  ): PublishContractAcceptanceResponse {
    const message = createBasePublishContractAcceptanceResponse();
    message.status = object.status ?? "";
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    return message;
  },
};

function createBasePublishContractUpdateProposalAcceptanceRequest(): PublishContractUpdateProposalAcceptanceRequest {
  return { contractId: new Uint8Array(0), proposalId: Long.UZERO };
}

export const PublishContractUpdateProposalAcceptanceRequest = {
  encode(
    message: PublishContractUpdateProposalAcceptanceRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contractId.length !== 0) {
      writer.uint32(10).bytes(message.contractId);
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.proposalId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishContractUpdateProposalAcceptanceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishContractUpdateProposalAcceptanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.proposalId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishContractUpdateProposalAcceptanceRequest {
    return {
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      proposalId: isSet(object.proposalId) ? Long.fromValue(object.proposalId) : Long.UZERO,
    };
  },

  toJSON(message: PublishContractUpdateProposalAcceptanceRequest): unknown {
    const obj: any = {};
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (!message.proposalId.equals(Long.UZERO)) {
      obj.proposalId = (message.proposalId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishContractUpdateProposalAcceptanceRequest>, I>>(
    base?: I,
  ): PublishContractUpdateProposalAcceptanceRequest {
    return PublishContractUpdateProposalAcceptanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishContractUpdateProposalAcceptanceRequest>, I>>(
    object: I,
  ): PublishContractUpdateProposalAcceptanceRequest {
    const message = createBasePublishContractUpdateProposalAcceptanceRequest();
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.UZERO;
    return message;
  },
};

function createBasePublishContractUpdateProposalAcceptanceResponse(): PublishContractUpdateProposalAcceptanceResponse {
  return { status: "", txId: Long.UZERO };
}

export const PublishContractUpdateProposalAcceptanceResponse = {
  encode(
    message: PublishContractUpdateProposalAcceptanceResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (!message.txId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.txId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishContractUpdateProposalAcceptanceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishContractUpdateProposalAcceptanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.txId = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishContractUpdateProposalAcceptanceResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      txId: isSet(object.txId) ? Long.fromValue(object.txId) : Long.UZERO,
    };
  },

  toJSON(message: PublishContractUpdateProposalAcceptanceResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (!message.txId.equals(Long.UZERO)) {
      obj.txId = (message.txId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishContractUpdateProposalAcceptanceResponse>, I>>(
    base?: I,
  ): PublishContractUpdateProposalAcceptanceResponse {
    return PublishContractUpdateProposalAcceptanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishContractUpdateProposalAcceptanceResponse>, I>>(
    object: I,
  ): PublishContractUpdateProposalAcceptanceResponse {
    const message = createBasePublishContractUpdateProposalAcceptanceResponse();
    message.status = object.status ?? "";
    message.txId = (object.txId !== undefined && object.txId !== null) ? Long.fromValue(object.txId) : Long.UZERO;
    return message;
  },
};

function createBaseGetMetadataResponse(): GetMetadataResponse {
  return { sidechains: [] };
}

export const GetMetadataResponse = {
  encode(message: GetMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.sidechains) {
      SidechainMetadata.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sidechains.push(SidechainMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetadataResponse {
    return {
      sidechains: globalThis.Array.isArray(object?.sidechains)
        ? object.sidechains.map((e: any) => SidechainMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMetadataResponse): unknown {
    const obj: any = {};
    if (message.sidechains?.length) {
      obj.sidechains = message.sidechains.map((e) => SidechainMetadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetadataResponse>, I>>(base?: I): GetMetadataResponse {
    return GetMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetadataResponse>, I>>(object: I): GetMetadataResponse {
    const message = createBaseGetMetadataResponse();
    message.sidechains = object.sidechains?.map((e) => SidechainMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSidechainMetadata(): SidechainMetadata {
  return { assetPublicKey: new Uint8Array(0), committedHeight: Long.UZERO, committedHash: new Uint8Array(0) };
}

export const SidechainMetadata = {
  encode(message: SidechainMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.assetPublicKey);
    }
    if (!message.committedHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.committedHeight);
    }
    if (message.committedHash.length !== 0) {
      writer.uint32(26).bytes(message.committedHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SidechainMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSidechainMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetPublicKey = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.committedHeight = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.committedHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SidechainMetadata {
    return {
      assetPublicKey: isSet(object.assetPublicKey) ? bytesFromBase64(object.assetPublicKey) : new Uint8Array(0),
      committedHeight: isSet(object.committedHeight) ? Long.fromValue(object.committedHeight) : Long.UZERO,
      committedHash: isSet(object.committedHash) ? bytesFromBase64(object.committedHash) : new Uint8Array(0),
    };
  },

  toJSON(message: SidechainMetadata): unknown {
    const obj: any = {};
    if (message.assetPublicKey.length !== 0) {
      obj.assetPublicKey = base64FromBytes(message.assetPublicKey);
    }
    if (!message.committedHeight.equals(Long.UZERO)) {
      obj.committedHeight = (message.committedHeight || Long.UZERO).toString();
    }
    if (message.committedHash.length !== 0) {
      obj.committedHash = base64FromBytes(message.committedHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SidechainMetadata>, I>>(base?: I): SidechainMetadata {
    return SidechainMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SidechainMetadata>, I>>(object: I): SidechainMetadata {
    const message = createBaseSidechainMetadata();
    message.assetPublicKey = object.assetPublicKey ?? new Uint8Array(0);
    message.committedHeight = (object.committedHeight !== undefined && object.committedHeight !== null)
      ? Long.fromValue(object.committedHeight)
      : Long.UZERO;
    message.committedHash = object.committedHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetTokenDataRequest(): GetTokenDataRequest {
  return { assetPubKey: new Uint8Array(0), uniqueId: new Uint8Array(0) };
}

export const GetTokenDataRequest = {
  encode(message: GetTokenDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetPubKey.length !== 0) {
      writer.uint32(10).bytes(message.assetPubKey);
    }
    if (message.uniqueId.length !== 0) {
      writer.uint32(18).bytes(message.uniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTokenDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetPubKey = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uniqueId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenDataRequest {
    return {
      assetPubKey: isSet(object.assetPubKey) ? bytesFromBase64(object.assetPubKey) : new Uint8Array(0),
      uniqueId: isSet(object.uniqueId) ? bytesFromBase64(object.uniqueId) : new Uint8Array(0),
    };
  },

  toJSON(message: GetTokenDataRequest): unknown {
    const obj: any = {};
    if (message.assetPubKey.length !== 0) {
      obj.assetPubKey = base64FromBytes(message.assetPubKey);
    }
    if (message.uniqueId.length !== 0) {
      obj.uniqueId = base64FromBytes(message.uniqueId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenDataRequest>, I>>(base?: I): GetTokenDataRequest {
    return GetTokenDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenDataRequest>, I>>(object: I): GetTokenDataRequest {
    const message = createBaseGetTokenDataRequest();
    message.assetPubKey = object.assetPubKey ?? new Uint8Array(0);
    message.uniqueId = object.uniqueId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetTokenDataResponse(): GetTokenDataResponse {
  return {};
}

export const GetTokenDataResponse = {
  encode(_: GetTokenDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTokenDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTokenDataResponse {
    return {};
  },

  toJSON(_: GetTokenDataResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenDataResponse>, I>>(base?: I): GetTokenDataResponse {
    return GetTokenDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenDataResponse>, I>>(_: I): GetTokenDataResponse {
    const message = createBaseGetTokenDataResponse();
    return message;
  },
};

function createBaseInvokeReadMethodRequest(): InvokeReadMethodRequest {
  return {
    contractId: new Uint8Array(0),
    templateId: 0,
    method: "",
    args: new Uint8Array(0),
    sender: new Uint8Array(0),
  };
}

export const InvokeReadMethodRequest = {
  encode(message: InvokeReadMethodRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractId.length !== 0) {
      writer.uint32(10).bytes(message.contractId);
    }
    if (message.templateId !== 0) {
      writer.uint32(16).uint32(message.templateId);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.args.length !== 0) {
      writer.uint32(34).bytes(message.args);
    }
    if (message.sender.length !== 0) {
      writer.uint32(42).bytes(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeReadMethodRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeReadMethodRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.templateId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.args = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sender = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeReadMethodRequest {
    return {
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      templateId: isSet(object.templateId) ? globalThis.Number(object.templateId) : 0,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      args: isSet(object.args) ? bytesFromBase64(object.args) : new Uint8Array(0),
      sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(0),
    };
  },

  toJSON(message: InvokeReadMethodRequest): unknown {
    const obj: any = {};
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.templateId !== 0) {
      obj.templateId = Math.round(message.templateId);
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.args.length !== 0) {
      obj.args = base64FromBytes(message.args);
    }
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeReadMethodRequest>, I>>(base?: I): InvokeReadMethodRequest {
    return InvokeReadMethodRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeReadMethodRequest>, I>>(object: I): InvokeReadMethodRequest {
    const message = createBaseInvokeReadMethodRequest();
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.templateId = object.templateId ?? 0;
    message.method = object.method ?? "";
    message.args = object.args ?? new Uint8Array(0);
    message.sender = object.sender ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInvokeReadMethodResponse(): InvokeReadMethodResponse {
  return { result: new Uint8Array(0), authority: undefined };
}

export const InvokeReadMethodResponse = {
  encode(message: InvokeReadMethodResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result.length !== 0) {
      writer.uint32(10).bytes(message.result);
    }
    if (message.authority !== undefined) {
      Authority.encode(message.authority, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeReadMethodResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeReadMethodResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authority = Authority.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeReadMethodResponse {
    return {
      result: isSet(object.result) ? bytesFromBase64(object.result) : new Uint8Array(0),
      authority: isSet(object.authority) ? Authority.fromJSON(object.authority) : undefined,
    };
  },

  toJSON(message: InvokeReadMethodResponse): unknown {
    const obj: any = {};
    if (message.result.length !== 0) {
      obj.result = base64FromBytes(message.result);
    }
    if (message.authority !== undefined) {
      obj.authority = Authority.toJSON(message.authority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeReadMethodResponse>, I>>(base?: I): InvokeReadMethodResponse {
    return InvokeReadMethodResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeReadMethodResponse>, I>>(object: I): InvokeReadMethodResponse {
    const message = createBaseInvokeReadMethodResponse();
    message.result = object.result ?? new Uint8Array(0);
    message.authority = (object.authority !== undefined && object.authority !== null)
      ? Authority.fromPartial(object.authority)
      : undefined;
    return message;
  },
};

function createBaseAuthority(): Authority {
  return { nodePublicKey: new Uint8Array(0), signature: new Uint8Array(0), proxiedBy: new Uint8Array(0) };
}

export const Authority = {
  encode(message: Authority, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodePublicKey.length !== 0) {
      writer.uint32(10).bytes(message.nodePublicKey);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.proxiedBy.length !== 0) {
      writer.uint32(26).bytes(message.proxiedBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Authority {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodePublicKey = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proxiedBy = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authority {
    return {
      nodePublicKey: isSet(object.nodePublicKey) ? bytesFromBase64(object.nodePublicKey) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      proxiedBy: isSet(object.proxiedBy) ? bytesFromBase64(object.proxiedBy) : new Uint8Array(0),
    };
  },

  toJSON(message: Authority): unknown {
    const obj: any = {};
    if (message.nodePublicKey.length !== 0) {
      obj.nodePublicKey = base64FromBytes(message.nodePublicKey);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.proxiedBy.length !== 0) {
      obj.proxiedBy = base64FromBytes(message.proxiedBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Authority>, I>>(base?: I): Authority {
    return Authority.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Authority>, I>>(object: I): Authority {
    const message = createBaseAuthority();
    message.nodePublicKey = object.nodePublicKey ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.proxiedBy = object.proxiedBy ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInvokeMethodRequest(): InvokeMethodRequest {
  return {
    contractId: new Uint8Array(0),
    templateId: 0,
    method: "",
    args: new Uint8Array(0),
    sender: new Uint8Array(0),
  };
}

export const InvokeMethodRequest = {
  encode(message: InvokeMethodRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractId.length !== 0) {
      writer.uint32(10).bytes(message.contractId);
    }
    if (message.templateId !== 0) {
      writer.uint32(16).uint32(message.templateId);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.args.length !== 0) {
      writer.uint32(34).bytes(message.args);
    }
    if (message.sender.length !== 0) {
      writer.uint32(42).bytes(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeMethodRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeMethodRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.templateId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.args = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sender = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeMethodRequest {
    return {
      contractId: isSet(object.contractId) ? bytesFromBase64(object.contractId) : new Uint8Array(0),
      templateId: isSet(object.templateId) ? globalThis.Number(object.templateId) : 0,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      args: isSet(object.args) ? bytesFromBase64(object.args) : new Uint8Array(0),
      sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(0),
    };
  },

  toJSON(message: InvokeMethodRequest): unknown {
    const obj: any = {};
    if (message.contractId.length !== 0) {
      obj.contractId = base64FromBytes(message.contractId);
    }
    if (message.templateId !== 0) {
      obj.templateId = Math.round(message.templateId);
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.args.length !== 0) {
      obj.args = base64FromBytes(message.args);
    }
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeMethodRequest>, I>>(base?: I): InvokeMethodRequest {
    return InvokeMethodRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeMethodRequest>, I>>(object: I): InvokeMethodRequest {
    const message = createBaseInvokeMethodRequest();
    message.contractId = object.contractId ?? new Uint8Array(0);
    message.templateId = object.templateId ?? 0;
    message.method = object.method ?? "";
    message.args = object.args ?? new Uint8Array(0);
    message.sender = object.sender ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInvokeMethodResponse(): InvokeMethodResponse {
  return { status: "", result: new Uint8Array(0) };
}

export const InvokeMethodResponse = {
  encode(message: InvokeMethodResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.result.length !== 0) {
      writer.uint32(18).bytes(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeMethodResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeMethodResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeMethodResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      result: isSet(object.result) ? bytesFromBase64(object.result) : new Uint8Array(0),
    };
  },

  toJSON(message: InvokeMethodResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.result.length !== 0) {
      obj.result = base64FromBytes(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvokeMethodResponse>, I>>(base?: I): InvokeMethodResponse {
    return InvokeMethodResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvokeMethodResponse>, I>>(object: I): InvokeMethodResponse {
    const message = createBaseInvokeMethodResponse();
    message.status = object.status ?? "";
    message.result = object.result ?? new Uint8Array(0);
    return message;
  },
};

export type ValidatorNodeService = typeof ValidatorNodeService;
export const ValidatorNodeService = {
  getIdentity: {
    path: "/tari.rpc.ValidatorNode/GetIdentity",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetIdentityRequest) => Buffer.from(GetIdentityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetIdentityRequest.decode(value),
    responseSerialize: (value: GetIdentityResponse) => Buffer.from(GetIdentityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetIdentityResponse.decode(value),
  },
  getMetadata: {
    path: "/tari.rpc.ValidatorNode/GetMetadata",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMetadataRequest) => Buffer.from(GetMetadataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetMetadataRequest.decode(value),
    responseSerialize: (value: GetMetadataResponse) => Buffer.from(GetMetadataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetMetadataResponse.decode(value),
  },
  getTokenData: {
    path: "/tari.rpc.ValidatorNode/GetTokenData",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTokenDataRequest) => Buffer.from(GetTokenDataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTokenDataRequest.decode(value),
    responseSerialize: (value: GetTokenDataResponse) => Buffer.from(GetTokenDataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTokenDataResponse.decode(value),
  },
  /** rpc ExecuteInstruction(ExecuteInstructionRequest) returns (ExecuteInstructionResponse); */
  invokeReadMethod: {
    path: "/tari.rpc.ValidatorNode/InvokeReadMethod",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InvokeReadMethodRequest) => Buffer.from(InvokeReadMethodRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InvokeReadMethodRequest.decode(value),
    responseSerialize: (value: InvokeReadMethodResponse) =>
      Buffer.from(InvokeReadMethodResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InvokeReadMethodResponse.decode(value),
  },
  invokeMethod: {
    path: "/tari.rpc.ValidatorNode/InvokeMethod",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InvokeMethodRequest) => Buffer.from(InvokeMethodRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InvokeMethodRequest.decode(value),
    responseSerialize: (value: InvokeMethodResponse) => Buffer.from(InvokeMethodResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InvokeMethodResponse.decode(value),
  },
  getConstitutionRequests: {
    path: "/tari.rpc.ValidatorNode/GetConstitutionRequests",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: GetConstitutionRequestsRequest) =>
      Buffer.from(GetConstitutionRequestsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetConstitutionRequestsRequest.decode(value),
    responseSerialize: (value: TransactionOutput) => Buffer.from(TransactionOutput.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionOutput.decode(value),
  },
  publishContractAcceptance: {
    path: "/tari.rpc.ValidatorNode/PublishContractAcceptance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PublishContractAcceptanceRequest) =>
      Buffer.from(PublishContractAcceptanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PublishContractAcceptanceRequest.decode(value),
    responseSerialize: (value: PublishContractAcceptanceResponse) =>
      Buffer.from(PublishContractAcceptanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PublishContractAcceptanceResponse.decode(value),
  },
  publishContractUpdateProposalAcceptance: {
    path: "/tari.rpc.ValidatorNode/PublishContractUpdateProposalAcceptance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PublishContractUpdateProposalAcceptanceRequest) =>
      Buffer.from(PublishContractUpdateProposalAcceptanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PublishContractUpdateProposalAcceptanceRequest.decode(value),
    responseSerialize: (value: PublishContractUpdateProposalAcceptanceResponse) =>
      Buffer.from(PublishContractUpdateProposalAcceptanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PublishContractUpdateProposalAcceptanceResponse.decode(value),
  },
} as const;

export interface ValidatorNodeServer extends UntypedServiceImplementation {
  getIdentity: handleUnaryCall<GetIdentityRequest, GetIdentityResponse>;
  getMetadata: handleUnaryCall<GetMetadataRequest, GetMetadataResponse>;
  getTokenData: handleUnaryCall<GetTokenDataRequest, GetTokenDataResponse>;
  /** rpc ExecuteInstruction(ExecuteInstructionRequest) returns (ExecuteInstructionResponse); */
  invokeReadMethod: handleUnaryCall<InvokeReadMethodRequest, InvokeReadMethodResponse>;
  invokeMethod: handleUnaryCall<InvokeMethodRequest, InvokeMethodResponse>;
  getConstitutionRequests: handleServerStreamingCall<GetConstitutionRequestsRequest, TransactionOutput>;
  publishContractAcceptance: handleUnaryCall<PublishContractAcceptanceRequest, PublishContractAcceptanceResponse>;
  publishContractUpdateProposalAcceptance: handleUnaryCall<
    PublishContractUpdateProposalAcceptanceRequest,
    PublishContractUpdateProposalAcceptanceResponse
  >;
}

export interface ValidatorNodeClient extends Client {
  getIdentity(
    request: GetIdentityRequest,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  getIdentity(
    request: GetIdentityRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  getIdentity(
    request: GetIdentityRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetIdentityResponse) => void,
  ): ClientUnaryCall;
  getMetadata(
    request: GetMetadataRequest,
    callback: (error: ServiceError | null, response: GetMetadataResponse) => void,
  ): ClientUnaryCall;
  getMetadata(
    request: GetMetadataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMetadataResponse) => void,
  ): ClientUnaryCall;
  getMetadata(
    request: GetMetadataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMetadataResponse) => void,
  ): ClientUnaryCall;
  getTokenData(
    request: GetTokenDataRequest,
    callback: (error: ServiceError | null, response: GetTokenDataResponse) => void,
  ): ClientUnaryCall;
  getTokenData(
    request: GetTokenDataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTokenDataResponse) => void,
  ): ClientUnaryCall;
  getTokenData(
    request: GetTokenDataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTokenDataResponse) => void,
  ): ClientUnaryCall;
  /** rpc ExecuteInstruction(ExecuteInstructionRequest) returns (ExecuteInstructionResponse); */
  invokeReadMethod(
    request: InvokeReadMethodRequest,
    callback: (error: ServiceError | null, response: InvokeReadMethodResponse) => void,
  ): ClientUnaryCall;
  invokeReadMethod(
    request: InvokeReadMethodRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InvokeReadMethodResponse) => void,
  ): ClientUnaryCall;
  invokeReadMethod(
    request: InvokeReadMethodRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InvokeReadMethodResponse) => void,
  ): ClientUnaryCall;
  invokeMethod(
    request: InvokeMethodRequest,
    callback: (error: ServiceError | null, response: InvokeMethodResponse) => void,
  ): ClientUnaryCall;
  invokeMethod(
    request: InvokeMethodRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InvokeMethodResponse) => void,
  ): ClientUnaryCall;
  invokeMethod(
    request: InvokeMethodRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InvokeMethodResponse) => void,
  ): ClientUnaryCall;
  getConstitutionRequests(
    request: GetConstitutionRequestsRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<TransactionOutput>;
  getConstitutionRequests(
    request: GetConstitutionRequestsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<TransactionOutput>;
  publishContractAcceptance(
    request: PublishContractAcceptanceRequest,
    callback: (error: ServiceError | null, response: PublishContractAcceptanceResponse) => void,
  ): ClientUnaryCall;
  publishContractAcceptance(
    request: PublishContractAcceptanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PublishContractAcceptanceResponse) => void,
  ): ClientUnaryCall;
  publishContractAcceptance(
    request: PublishContractAcceptanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PublishContractAcceptanceResponse) => void,
  ): ClientUnaryCall;
  publishContractUpdateProposalAcceptance(
    request: PublishContractUpdateProposalAcceptanceRequest,
    callback: (error: ServiceError | null, response: PublishContractUpdateProposalAcceptanceResponse) => void,
  ): ClientUnaryCall;
  publishContractUpdateProposalAcceptance(
    request: PublishContractUpdateProposalAcceptanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PublishContractUpdateProposalAcceptanceResponse) => void,
  ): ClientUnaryCall;
  publishContractUpdateProposalAcceptance(
    request: PublishContractUpdateProposalAcceptanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PublishContractUpdateProposalAcceptanceResponse) => void,
  ): ClientUnaryCall;
}

export const ValidatorNodeClient = makeGenericClientConstructor(
  ValidatorNodeService,
  "tari.rpc.ValidatorNode",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ValidatorNodeClient;
  service: typeof ValidatorNodeService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
